<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C++字符串分割</title>
    <url>/2021/05/10/C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2/</url>
    <content><![CDATA[<p>字符串分割方式汇总</p>
<span id="more"></span>

<h2 id="string-find"><a href="#string-find" class="headerlink" title="string.find"></a>string.find</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line">std::string delimiter = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> pos = <span class="number">0</span>;</span><br><span class="line">std::string token;</span><br><span class="line">std::vector&lt;string&gt; v;</span><br><span class="line"><span class="keyword">while</span> ((pos = s.<span class="built_in">find</span>(delimiter)) != std::string::npos) &#123;</span><br><span class="line">    token = s.<span class="built_in">substr</span>(<span class="number">0</span>, pos);</span><br><span class="line">    v.<span class="built_in">push_back</span>(token);</span><br><span class="line">    s.<span class="built_in">erase</span>(<span class="number">0</span>, pos + delimiter.<span class="built_in">length</span>());</span><br><span class="line">&#125;</span><br><span class="line">v.<span class="built_in">push_back</span>(s);</span><br></pre></td></tr></table></figure>

<h2 id="boost-split"><a href="#boost-split" class="headerlink" title="boost::split()"></a>boost::split()</h2><p>注意split在处理多字符分隔符的时候会有一些更奇妙的行为。<br>此外要处理结果中的空字符串。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string line = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line">boost::<span class="built_in">split</span>(v,line,boost::<span class="built_in">is_any_of</span>(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="strotk"><a href="#strotk" class="headerlink" title="strotk"></a>strotk</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;scott,tiger,mushroom&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> *token = <span class="built_in">strtok</span>(str.<span class="built_in">data</span>(), <span class="string">&quot;,&quot;</span>);</span><br><span class="line">std::vector&lt;std::string&gt; v;</span><br><span class="line"><span class="keyword">while</span> (token != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    token = <span class="built_in">strtok</span>(<span class="literal">NULL</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    v.<span class="built_in">push_back</span>(std::<span class="built_in">string</span>(token));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程技巧</category>
      </categories>
      <tags>
        <tag>c++/cpp</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 输入输出 stdio</title>
    <url>/2021/06/14/Golang%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%20stdio/</url>
    <content><![CDATA[<p>Golang 的标准输入输出常见用法</p>
<span id="more"></span>

<h1 id="按行读取"><a href="#按行读取" class="headerlink" title="按行读取"></a>按行读取</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// Scanln 实际上需要知道一行中有多少被空格分隔的输入才能使用，直接读取一行作为字符串需要用到scanner或者reader</span></span><br><span class="line">	<span class="comment">// var str1, str2 string</span></span><br><span class="line">	<span class="comment">// fmt.Scanln(str1, str2) </span></span><br><span class="line">	<span class="comment">// fmt.Println(str1, str2);</span></span><br><span class="line">  <span class="comment">// 方式一：</span></span><br><span class="line">  scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">      fmt.Println(scanner.Text())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 方式二：</span></span><br><span class="line">  reader := bufio.NewReader(os.Stdin)</span><br><span class="line">  text, _ := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">  fmt.Println(text)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="空格分割"><a href="#空格分割" class="headerlink" title="空格分割"></a>空格分割</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;bufio&quot;</span></span><br><span class="line">  <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 方式一：</span></span><br><span class="line">  scanner := bufio.NewScanner(bufio.NewReader(os.Stdin))</span><br><span class="line">  scanner.Split(bufio.ScanWords)</span><br><span class="line">  <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">      fmt.Println(scanner.Text())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h1><figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;abc&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="number">100.12</span></span><br><span class="line">  <span class="comment">// 保留一位小数</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%.1f\n&quot;</span>, str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>stdio</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang 调用 Linux Netlink 管理路由表</title>
    <url>/2020/07/07/Golang-%E8%B0%83%E7%94%A8-Linux-Netlink-%E7%AE%A1%E7%90%86%E8%B7%AF%E7%94%B1%E8%A1%A8/</url>
    <content><![CDATA[<p>通常我们使用route命令或者ip命令来管理linux路由表(routing table), 但是如何使用linux原生的接口来进行操作呢？</p>
<span id="more"></span>

<h2 id="NetLink"><a href="#NetLink" class="headerlink" title="NetLink"></a>NetLink</h2><p>netlink 是一种与内核交互的方式，首先创建一个netlink类型的socket，之后向这个socket发送指定格式的数据，就可以从该socket拿到内核的返回。<br>linux的route就是通过这种方式来进行管理的。<br>关于netlink的详细信息建议直接<code>man 7 netlink</code>，网上的信息通常都不够直观。下面节选部分文档</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NETLINK(7) </span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       netlink - communication between kernel and user space (AF_NETLINK)</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;asm&#x2F;types.h&gt;</span><br><span class="line">       #include &lt;sys&#x2F;socket.h&gt;</span><br><span class="line">       #include &lt;linux&#x2F;netlink.h&gt;</span><br><span class="line"></span><br><span class="line">       netlink_socket &#x3D; socket(AF_NETLINK, socket_type, netlink_family);</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Netlink  is  used to transfer information between the kernel and user-space processes.  It consists of a standard sockets-based interface for user space processes and an internal kernel API for</span><br><span class="line">       kernel modules.  The internal kernel interface is not documented in this manual page.  There is also an obsolete netlink interface via netlink character devices; this  interface  is  not  docu‐</span><br><span class="line">       mented here and is provided only for backward compatibility.</span><br><span class="line"></span><br><span class="line">       Netlink is a datagram-oriented service.  Both SOCK_RAW and SOCK_DGRAM are valid values for socket_type.  However, the netlink protocol does not distinguish between datagram and raw sockets.</span><br><span class="line"></span><br><span class="line">       netlink_family selects the kernel module or netlink group to communicate with.  The currently assigned netlink families are:</span><br><span class="line"></span><br><span class="line">       NETLINK_ROUTE</span><br><span class="line">              Receives routing and link updates and may be used to modify the routing tables (both IPv4 and IPv6), IP addresses, link parameters, neighbor setups, queueing disciplines, traffic classes</span><br><span class="line">              and packet classifiers (see rtnetlink(7)).</span><br><span class="line"></span><br><span class="line">       NETLINK_W1 (Linux 2.6.13 to 2.16.17)</span><br><span class="line">              Messages from 1-wire subsystem.</span><br><span class="line"></span><br><span class="line">       NETLINK_USERSOCK</span><br><span class="line">              Reserved for user-mode socket protocols.</span><br><span class="line"></span><br><span class="line">       NETLINK_FIREWALL (up to and including Linux 3.4)</span><br><span class="line">              Transport IPv4 packets from netfilter to user space.  Used by ip_queue kernel module.  After a long period of being declared obsolete (in favor of the more advanced nfnetlink_queue  fea‐</span><br><span class="line">              ture), NETLINK_FIREWALL was removed in Linux 3.5.</span><br></pre></td></tr></table></figure>

<h2 id="golang-netlink-接口"><a href="#golang-netlink-接口" class="headerlink" title="golang netlink 接口"></a>golang netlink 接口</h2><h2 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h2><p>goalng的syscall库中包装了部分函数帮助我们通过netlink完成查询工作。方便起见我们使用最为通用的<code>syscall.NetlinkRIB</code>函数，该函数会一次将所有table查询出来，无法指定，但是不需要我们手动设置查询结构体，同时帮我们完成了数据接收工作，使用起来较为方便。<br><code>syscall.NetlinkRIB</code>的返回为[]byte，我们需要手动将该字节串转为结构体。在syscall中提供了<code>syscall.ParseNetlinkMessage</code>函数可以帮我们完成这一步操作。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">tab, err := syscall.NetlinkRIB(syscall.RTM_GETROUTE, syscall.AF_INET)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">msgs, err := syscall.ParseNetlinkMessage(tab)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>msgs</code>类型为<code>[]NetlinkMessage</code>每一个table中的路由都会被存储为一个<code>NetlinkMessage</code>结构体，接下来我们遍历<code>msgs</code>来取出所有table的路由。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, m := <span class="keyword">range</span> msgs &#123;</span><br><span class="line">	<span class="keyword">switch</span> m.Header.Type &#123;</span><br><span class="line">		<span class="keyword">case</span> syscall.NLMSG_DONE:</span><br><span class="line">			fmt.Println(<span class="string">&quot;recv done&quot;</span>)</span><br><span class="line">			<span class="keyword">goto</span> done</span><br><span class="line">        <span class="keyword">case</span> syscall.RTM_NEWROUTE:</span><br><span class="line">            <span class="comment">// 解析数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure>

<p>对于每一个<code>NetlinkMessage</code>结构，我们需要先判断其类型，如果为<code>NLMSG_DONE</code>则表示数据结束，有人可能觉得数组遍历完了就好，为什么非要把最后一个元素设置为<code>NLMSG_DONE</code>，这其实也是socket传输结束的标志，<code>NetlinkRIB</code>和<code>ParseNetlinkMessage</code>只是将他原样解析了而已。</p>
<p>第二个需要注意的点是，我们使用<code>syscall.RTM_GETROUTE</code>标志get的到的路由表，其头类型为<code>syscall.RTM_NEWROUTE</code>而不是<code>syscall.RTM_GETROUTE</code>，其原因我还没有仔细查过。</p>
<h2 id="路由-表属性-解析"><a href="#路由-表属性-解析" class="headerlink" title="路由 表属性 解析"></a>路由 表属性 解析</h2><p>当进入<code>case syscall.RTM_NEWROUTE:</code>分支后，我们就可以拿到一个路由表的具体数据了。首先需要使用unsafe指针将<code>NetlinkMessage</code>的data解析为<code>RtMsg</code>结构体。之后我们可以从<code>rtmsg</code>中解析出路由表的各项属性。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">rtmsg := (*syscall.RtMsg)(unsafe.Pointer(&amp;m.Data[<span class="number">0</span>]))</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot;Scope &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Scope &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_UNIVERSE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_UNIVERSE &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_SITE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_SITE &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_LINK:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_LINK &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_HOST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_HOST &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RT_SCOPE_NOWHERE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RT_SCOPE_NOWHERE &quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot; Protocol &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Protocol &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_UNSPEC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_UNSPEC&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_REDIRECT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_REDIRECT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_KERNEL:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_KERNEL&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_BOOT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_BOOT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTPROT_STATIC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTPROT_STATIC&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Print(<span class="string">&quot; Type &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNSPEC:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNSPEC&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNICAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNICAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_LOCAL:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_LOCAL&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_BROADCAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_BROADCAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_ANYCAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_ANYCAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_MULTICAST:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_MULTICAST&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_BLACKHOLE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_BLACKHOLE&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_UNREACHABLE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_UNREACHABLE&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_PROHIBIT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_PROHIBIT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_THROW:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_THROW&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_NAT:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_NAT&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTN_XRESOLVE:</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTN_XRESOLVE&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Print(<span class="string">&quot; Family &quot;</span>)</span><br><span class="line"><span class="keyword">switch</span> rtmsg.Family &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.AF_INET:</span><br><span class="line">        fmt.Print(<span class="string">&quot;AF_INET&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.AF_INET6:</span><br><span class="line">        fmt.Print(<span class="string">&quot;AF_INET6&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="路由-解析"><a href="#路由-解析" class="headerlink" title="路由 解析"></a>路由 解析</h2><p>使用<code>syscall.ParseNetlinkRouteAttr</code>函数可以将<code>NetlinkMessage</code>结构体中的每一项路由属性解析出来。每一个<code>attr</code>既代表路由表中的一项路由</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">attrs, err := syscall.ParseNetlinkRouteAttr(&amp;m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, attr := <span class="keyword">range</span> attrs &#123;</span><br><span class="line">    <span class="keyword">switch</span> attr.Attr.Type &#123;</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_DST:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_DST &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_SRC:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_SRC &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_GATEWAY:</span><br><span class="line">        ip := net.IPv4(attr.Value[<span class="number">0</span>], attr.Value[<span class="number">1</span>], attr.Value[<span class="number">2</span>], attr.Value[<span class="number">3</span>])</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_GATEWAY &quot;</span>, ip.String(), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_PRIORITY:</span><br><span class="line">        priority := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_PRIORITY &quot;</span>, priority, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_TABLE:</span><br><span class="line">        table := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_TABLE &quot;</span>, strconv.Itoa(table), <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_METRICS:</span><br><span class="line">        metrics := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_METRICS &quot;</span>, metrics, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_IIF:</span><br><span class="line">        iif := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_IIF &quot;</span>, iif, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> syscall.RTA_OIF:</span><br><span class="line">        oif := *(*<span class="keyword">int32</span>)(unsafe.Pointer(&amp;attr.Value[<span class="number">0</span>]))</span><br><span class="line">        fmt.Print(<span class="string">&quot;RTA_OIF &quot;</span>, oif, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;============&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.studygolang.com/2017/07/linux-netlink-and-go-part-1-netlink/">LINUX，NETLINK 和 GO – 第 1 部分：NETLINK</a></li>
<li><a href="https://mdlayher.com/blog/linux-netlink-and-go-part-1-netlink/">Linux, Netlink, and Go - Part 1: netlink</a></li>
<li>[<a href="https://beej-zhcn.netdpi.net/]">https://beej-zhcn.netdpi.net/]</a>(Beej’s Guide to Network Programming)</li>
<li><a href="https://tools.ietf.org/html/rfc3549#section-2.3.2">RFC3549</a></li>
</ol>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>linux</tag>
        <tag>table</tag>
        <tag>route</tag>
        <tag>routing</tag>
        <tag>netlink</tag>
      </tags>
  </entry>
  <entry>
    <title>LRU相关题目</title>
    <url>/2021/05/03/LRU%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>LRU(最近最少使用缓存)相关题目</p>
<span id="more"></span>

<h1 id="LRU-最近最少使用-缓存机制-MD"><a href="#LRU-最近最少使用-缓存机制-MD" class="headerlink" title="LRU (最近最少使用) 缓存机制.MD"></a>LRU (最近最少使用) 缓存机制.MD</h1><p><a href="https://leetcode-cn.com/problems/lru-cache/submissions/">https://leetcode-cn.com/problems/lru-cache/submissions/</a></p>
<p>需要用到一个哈希表和一个双向链表。哈希表记录链表节点和键值</p>
<p>每次进行put或get时操作链表，将节点移动至队头。</p>
<p>使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>LRU</tag>
      </tags>
  </entry>
  <entry>
    <title>NFS挂载失效处理</title>
    <url>/2020/07/07/NFS%E6%8C%82%E8%BD%BD%E5%A4%B1%E6%95%88%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在使用NFS的过程中，我们往往会遇到网络问题导致NFS断开，不幸的是，当NFS断开的时候，NFS会继续尝试重连而不会报错，此时如果有软件尝试读取NFS中的内容，就会卡在read函数中无法kill掉。由于文件系统的read不超时，所以它就会永远的卡在里面。同样的现象也会发生在我们尝试执行df命令或者ls NFS目录的时候。此时必须先解挂NFS目录，使程序退出read。</p>
<span id="more"></span>

<h2 id="查找NFS目录位置"><a href="#查找NFS目录位置" class="headerlink" title="查找NFS目录位置"></a>查找NFS目录位置</h2><p>由于NFS目录直接卡死，导致df等命令直接失效，我们只能曲线救国查询NFS目录位置。通常来说，下述两条命令都可以正确执行。</p>
<ol>
<li><code>nfsstat -m</code></li>
<li><code>mount</code></li>
</ol>
<h2 id="解挂"><a href="#解挂" class="headerlink" title="解挂"></a>解挂</h2><p>解挂可以尝试<code>umount -f /path</code>如果提示目录忙，可以继续尝<code>umount -l /path</code>。解挂后相关程序就可以正常退出，此时在重新挂载NFS启动即可。</p>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>nfs</tag>
      </tags>
  </entry>
  <entry>
    <title>Nvidia Triton 使用教程</title>
    <url>/2021/06/10/Nvidia%20Triton%20Server%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>近年来，在深度学习模型的部署中，涌现了许多新技术，从最早的tf/pytorch直接部署，到onnx，到trnsorrt(trt)，模型的运行效率越来越高。但即便是使用trt方式部署模型，也依旧无法避免巨大的工作量。在使用c++部署trt时，代码量较大，还需要预处理困难。而使用python部署trt，受限于python的GIL问题，需要同时部署多个模型，又失去了trt节省显存的优点。同时，不论使用何种方式，都无法避免面对组batch等问题，整个系统的工程实现会变得非常复杂。<br>在这样的情况下，triton应运而生一站式的帮助我们解决了几乎所有的工程问题，作为一款强大的模型执行引擎，triton支持几乎所有主流的网络模型，对于pytorch，tensorflow，onnx，trt都有良好的支持。</p>
<p>本文将从trt/onnx模型的部署介绍triton的部署流程。</p>
<span id="more"></span>

<h1 id="triton项目的组件"><a href="#triton项目的组件" class="headerlink" title="triton项目的组件"></a>triton项目的组件</h1><ol>
<li><p><a href="https://github.com/triton-inference-server/server">triton server</a><br>triton的服务端可以直接使用docker方式部署，从(triton的镜像列表)[<a href="https://ngc.nvidia.com/catalog/containers/nvidia:tritonserver/tags]%E4%B8%AD%E9%80%89%E6%8B%A9tag%E4%B8%BAxx.xx-py3%E7%9A%84%E9%95%9C%E5%83%8F%E5%8D%B3%E5%8F%AF%E3%80%82">https://ngc.nvidia.com/catalog/containers/nvidia:tritonserver/tags]中选择tag为xx.xx-py3的镜像即可。</a></p>
</li>
<li><p><a href="https://github.com/triton-inference-server/client">triton client</a><br>triton的客户端可以从pip直接安装，但为了测试方便，可以直接使用包含测试端的容器环境，tag为xx.xx-py3-sdk的镜像中包含了客户端。</p>
</li>
</ol>
<h1 id="triton-server"><a href="#triton-server" class="headerlink" title="triton server"></a>triton server</h1><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>triton部署模型可以参考<a href="https://github.com/triton-inference-server/server/blob/main/docs/quickstart.md#create-a-model-repository">文档1</a>和<a href="https://github.com/triton-inference-server/server/blob/main/docs/model_repository.md">文档2</a>，但是对于onnx和trt模型，由于模型内已经包含了输入和输出的信息，因此triton可以自动生成配置文件，部署会变得非常简单。</p>
<p>按照triton的教程，我们创建三层目录结构，之后直接把onnx或trt模型拷贝进去即可。</p>
<p>onnx的默认模型名称为model.onnx，而trt的默认模型名称为model.plan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p model_repository/your_model_name/1</span><br><span class="line"><span class="comment"># onnx</span></span><br><span class="line">cp your_model_name.onnx model_repository/your_model_name/1/model.onnx</span><br><span class="line"><span class="comment"># trt</span></span><br><span class="line">cp your_model_name.trt model_repository/your_model_name/1/model.plan</span><br></pre></td></tr></table></figure>

<p>此时你的目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;model-repository-path&gt;/</span><br><span class="line">  &lt;your_model_name&gt;/</span><br><span class="line">    1/</span><br><span class="line">      model.plan</span><br></pre></td></tr></table></figure>

<p>准备好模型文件的目录结构之后，我们启动triton服务，并使用<code>--strict-model-config=false</code>要求他自动生成模型文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --rm --gpus all \</span><br><span class="line">-p8000:8000 -p8001:8001 -p8002:8002 \</span><br><span class="line">-v model_repository:/models \</span><br><span class="line">nvcr.io/nvidia/tritonserver:21.05-py3 \</span><br><span class="line">tritonserver --strict-model-config=<span class="literal">false</span> --model-repository=/models</span><br></pre></td></tr></table></figure>

<p>如果模型正常启动，你将会看到类似下面的的输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+----------------------+---------+--------+</span><br><span class="line">| Model                | Version | Status |</span><br><span class="line">+----------------------+---------+--------+</span><br><span class="line">| &lt;model_name&gt;         | &lt;v&gt;     | READY  |</span><br><span class="line">| ..                   | .       | ..     |</span><br><span class="line">| ..                   | .       | ..     |</span><br><span class="line">+----------------------+---------+--------+</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">I1002 21:58:57.891440 62 grpc_server.cc:3914] Started GRPCInferenceService at 0.0.0.0:8001</span><br><span class="line">I1002 21:58:57.893177 62 http_server.cc:2717] Started HTTPService at 0.0.0.0:8000</span><br><span class="line">I1002 21:58:57.935518 62 http_server.cc:2736] Started Metrics Service at 0.0.0.0:8002</span><br></pre></td></tr></table></figure>

<h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>接下来我们需要修改triton为我们生成的配置文件，使用如下命令可以获得当前的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl localhost:8000&#x2F;v2&#x2F;models&#x2F;&lt;your_model_name&gt;&#x2F;config</span><br></pre></td></tr></table></figure>

<p>得到json输出之后，我们需要收到修改为pbconfig的格式。可以参考<a href="https://github.com/triton-inference-server/server/blob/main/docs/model_configuration.md">这篇教程</a>，基本格式如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">platform: &quot;your_model_name&quot;</span><br><span class="line">max_batch_size: 8</span><br><span class="line">input [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;input0&quot;</span><br><span class="line">    data_type: TYPE_FP32</span><br><span class="line">    dims: [ 16 ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line">output [</span><br><span class="line">  &#123;</span><br><span class="line">    name: &quot;output0&quot;</span><br><span class="line">    data_type: TYPE_FP32</span><br><span class="line">    dims: [ 4 ]</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>修改之后，保存为<code>model_repository/your_model_name/config.pbtxt</code>，保存后你的模型目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;model-repository-path&gt;&#x2F;</span><br><span class="line">  &lt;your_model_name&gt;&#x2F;</span><br><span class="line">    config.pbtxt</span><br><span class="line">    1&#x2F;</span><br><span class="line">      model.plan</span><br></pre></td></tr></table></figure>

<p>这时我们可以关闭triton，去掉<code>--strict-model-config=false</code>选项后重启服务，修改好的配置文件就会生效了。</p>
<h1 id="triton-client"><a href="#triton-client" class="headerlink" title="triton client"></a>triton client</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>此处以python client为例</p>
<p>triton python client的安装非常简单，使用如下方式即可，如果你只使用http或grpc方式调用，可以将<code>tritonclient[all]</code>替换为<code>tritonclient[http]</code>或<code>tritonclient[grpc]</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install nvidia-pyindex</span><br><span class="line">pip install tritonclient[all]</span><br></pre></td></tr></table></figure>

<p>如果你安装完之后报错<code>ModuleNotFoundError: No module named &#39;tritonclient&#39;</code>不妨尝试一下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python -m pip install nvidia-pyindex</span><br><span class="line">python -m pip install tritonclient[all]</span><br></pre></td></tr></table></figure>
<p>这样可以确保你的依赖被安装到你使用的python环境中。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>根据我的测试，grpc方式调用triton的性能远远高于http方式，在极端情况下甚至可以达到十倍的性能差距，因此如果没有特殊需要，我不建议使用http方式调用。</p>
<p>客户端示例可以看<a href="https://github.com/triton-inference-server/client/tree/main/src/python/examples">此处</a>，推荐从<code>simple_grpc_infer_client.py</code>这个例子入手</p>
<h2 id="shared-memory"><a href="#shared-memory" class="headerlink" title="shared memory"></a>shared memory</h2><p>对于本机内部调用，triton还支持使用shm方式进行数据共享，减小通信开销。更进一步的，你还可以使用cuda shm方式直接共享显存，在数据发送端就将显存设置好，直接调用triton进行推理。但需要注意的是cuda shm会消耗较多显存，需要用户自己去控制，否则会导致显存用尽，在我自己的测试中，grpc性能已经足够支撑，不需要在进行shm方式的优化了。</p>
<h2 id="异步模式-async-mode"><a href="#异步模式-async-mode" class="headerlink" title="异步模式(async mode)"></a>异步模式(async mode)</h2><p>triton client还支持异步调用，可以查看<code>simple_grpc_async_infer_client.py</code>。</p>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>triton</tag>
      </tags>
  </entry>
  <entry>
    <title>ONNX 模型 转 TRT engine</title>
    <url>/2021/06/10/ONNX%E6%A8%A1%E5%9E%8B%E8%BD%ACTRT%20engine/</url>
    <content><![CDATA[<p>本文将介绍如何将ONNX文件转换为TRT engine文件</p>
<span id="more"></span>

<h2 id="准备转换环境"><a href="#准备转换环境" class="headerlink" title="准备转换环境"></a>准备转换环境</h2><p>强烈不推荐自己搭建，可以直接使用nvidia官方的trt环境（如nvcr.io/nvidia/tritonserver:21.05-py3），之后运行也可以直接在容器中运行。</p>
<h2 id="python方案"><a href="#python方案" class="headerlink" title="python方案"></a>python方案</h2><p>在进入容器后，可以使用如下的python脚本进行转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env python</span><br><span class="line"># coding&#x3D;utf-8</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import argparse</span><br><span class="line">import tensorrt as trt</span><br><span class="line"></span><br><span class="line">EXPLICIT_BATCH &#x3D; 1 &lt;&lt; (int)(trt.NetworkDefinitionCreationFlag.EXPLICIT_BATCH)</span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">    parser &#x3D; argparse.ArgumentParser(description&#x3D;&quot;PyTorch Object Detection Inference&quot;)</span><br><span class="line">    parser.add_argument(&quot;--onnx_path&quot;, default&#x3D;&quot;&quot;, dest&#x3D;&quot;onnx_path&quot;, help&#x3D;&quot;path to onnx file&quot;, type&#x3D;str)</span><br><span class="line">    parser.add_argument(&quot;--trt_path&quot;, default&#x3D;&quot;&quot;, dest&#x3D;&quot;trt_path&quot;, help&#x3D;&quot;path to trt file&quot;, type&#x3D;str)</span><br><span class="line">    args &#x3D; parser.parse_args()</span><br><span class="line">    onnx_file_path &#x3D; args.onnx_path</span><br><span class="line">    engine_file_path &#x3D; args.trt_path</span><br><span class="line">    print(&#39;get start&#39;)</span><br><span class="line">    TRT_LOGGER &#x3D; trt.Logger()</span><br><span class="line">    with trt.Builder(TRT_LOGGER) as builder, builder.create_network(EXPLICIT_BATCH) as network, trt.OnnxParser(network, TRT_LOGGER) as parser:</span><br><span class="line">        config &#x3D; builder.create_builder_config()</span><br><span class="line">        #builder.max_workspace_size &#x3D;( 1 &lt;&lt; 30 ) * 2</span><br><span class="line">        config.max_workspace_size &#x3D;( 1 &lt;&lt; 20 ) * 3 * 1024 # 3GB，可以根据需求改的更大</span><br><span class="line">        builder.max_batch_size &#x3D; 128</span><br><span class="line">        config.set_flag(trt.BuilderFlag.FP16)</span><br><span class="line">        #builder.fp16_mode &#x3D; True</span><br><span class="line">        # Parse model file</span><br><span class="line">        if not os.path.exists(onnx_file_path):</span><br><span class="line">            print(&#39;ONNX file &#123;&#125; not found, please run yolov3_to_onnx.py first to generate it.&#39;.format(onnx_file_path))</span><br><span class="line">            exit(0)</span><br><span class="line">        print(&#39;Loading ONNX file from path &#123;&#125;...&#39;.format(onnx_file_path))</span><br><span class="line">        with open(onnx_file_path, &#39;rb&#39;) as model:</span><br><span class="line">            print(&#39;Beginning ONNX file parsing&#39;)</span><br><span class="line">            if not parser.parse(model.read()):</span><br><span class="line">                print (&#39;ERROR: Failed to parse the ONNX file.&#39;)</span><br><span class="line">                for error in range(parser.num_errors):</span><br><span class="line">                    print (parser.get_error(error))</span><br><span class="line">        print(f&quot;raw shape of &#123;network.get_input(0).name&#125; is: &quot;, network.get_input(0).shape)</span><br><span class="line">        # network.get_input(0).shape &#x3D; [-1, 3, 32, -1] #dynamic model example</span><br><span class="line">        for i in range(1):</span><br><span class="line">            profile &#x3D; builder.create_optimization_profile()</span><br><span class="line">            # 最小值 常规值 最大值</span><br><span class="line">            profile.set_shape(network.get_input(0).name, (1, 3, 32, 32), (16, 3, 32, 320), (128, 3, 32, 960))</span><br><span class="line">            config.add_optimization_profile(profile)</span><br><span class="line">        print(&#39;Completed parsing of ONNX file&#39;)</span><br><span class="line">        print(&#39;Building an engine from file &#123;&#125;; this may take a while...&#39;.format(onnx_file_path))</span><br><span class="line">        engine &#x3D; builder.build_engine(network,config)</span><br><span class="line">        print(&quot;Completed creating Engine&quot;)</span><br><span class="line">        with open(engine_file_path, &quot;wb&quot;) as f:</span><br><span class="line">            f.write(engine.serialize())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="官方工具转换"><a href="#官方工具转换" class="headerlink" title="官方工具转换"></a>官方工具转换</h2><p>推荐使用官方工具，简单快捷</p>
<ul>
<li><p>–workspace=4096 单位为MB</p>
</li>
<li><p>–explicitBatch 开启动态batch</p>
</li>
<li><p>–minShapes 最小输入 </p>
<p>格式为 节点名:<code>&lt;b&gt;x&lt;d1&gt;x&lt;d2&gt;x...x&lt;dn&gt;</code> </p>
<p>注意节点名的引号需要使用反斜杠转译，如网络输入节点是’data’，那么需要写成<code>\&#39;data\&#39;:1x2x3x4</code>这样的格式。</p>
</li>
<li><p>–optShapes 平均输入</p>
</li>
<li><p>–maxShapes 最大输入</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run --gpus all --rm -v /models:/models nvcr.io/nvidia/tensorrt:21.04-py3 \</span><br><span class="line">/usr/src/tensorrt/bin/trtexec --explicitBatch --workspace=4096 \</span><br><span class="line">--minShapes=\<span class="string">&#x27;data\&#x27;</span>:1x3x32x32 --optShapes=\<span class="string">&#x27;data\&#x27;</span>:128x3x32x320 --maxShapes=\<span class="string">&#x27;data\&#x27;</span>:256x3x32x960 --fp16 \</span><br><span class="line">--onnx=/models/model.onnx --saveEngine=/models/model.plan</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>GPU</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>tensorrt</tag>
        <tag>onnx</tag>
        <tag>trtexec</tag>
      </tags>
  </entry>
  <entry>
    <title>Python使用Pipe控制命令行输入输出</title>
    <url>/2021/07/13/Python%E4%BD%BF%E7%94%A8Pipe%E6%8E%A7%E5%88%B6%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>在开发过程中，我们有时需要在python中调用诸如ffmpeg这样的命令。此时就不可避免的需要用到pipe。</p>
<span id="more"></span>

<p>当我们仅需要使用输入或输出时，可以直接指定stdin/stdout/stderr为Pipe，但是当我们需要同事使用输入输出时，直接使用pipe的读写时无法工作的。</p>
<p>此时只能使用<code>pipe.communicate</code>方法，通过这种一锤子买卖一次性把所有的输入设置完，并读取所有的输出。</p>
<p>下面的例子是一个使用pipe将音频文件的字节流送给ffmpeg处理，并且从ffmpeg读取处理结果的例子。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import subprocess</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># init command</span><br><span class="line">ffmpeg_command &#x3D; [&quot;ffmpeg&quot;, &quot;-f&quot;, &quot;aac&quot;,&quot;-i&quot;, &quot;-&quot;, &quot;-f&quot;, &quot;wav&quot;, &quot;-&quot;]</span><br><span class="line"></span><br><span class="line"># excute ffmpeg command</span><br><span class="line">pipe &#x3D; subprocess.Popen(ffmpeg_command,</span><br><span class="line">                    stdin&#x3D;subprocess.PIPE,</span><br><span class="line">                    stdout&#x3D;subprocess.PIPE,</span><br><span class="line">                    bufsize&#x3D;1024*1024*128)</span><br><span class="line"></span><br><span class="line">with open(&quot;ft_local&#x2F;audio.aac&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    data &#x3D; f.read()</span><br><span class="line">    output, stderr &#x3D; pipe.communicate(data)</span><br><span class="line"></span><br><span class="line">with open(&quot;test.wav&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    data &#x3D; output</span><br><span class="line">    print(len(data))</span><br><span class="line">    f.write(data)</span><br><span class="line">pipe.wait()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pipe</tag>
        <tag>ffmpeg</tag>
      </tags>
  </entry>
  <entry>
    <title>Yolo发展整理</title>
    <url>/2021/05/03/Yolo%E5%8F%91%E5%B1%95%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>因为算法面试，整理了一些yolo相关的点</p>
<span id="more"></span>

<h2 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h2><p>region proposals 而不是滑动窗口</p>
<p>输入尺寸固定</p>
<p>小目标检测不好</p>
<p>一个单元格只能预测两个框和一个类别</p>
<h2 id="yolo9000"><a href="#yolo9000" class="headerlink" title="yolo9000"></a>yolo9000</h2><p>替换全连接为卷积，没有了输入尺寸的限制</p>
<p>引入anchor box, 使用kmeans聚类，5 anchor</p>
<p>darknet-19</p>
<p>13 * 13 detection， 2种尺度13 * 13， 26 * 26</p>
<p>训练过程中遇到带标签的检测图像，就基于 YOLOv2 整个损失函数进行反向传播，遇到分类图像，只反向传播网络的分类损失。</p>
<h2 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h2><p>9 anchor</p>
<p>darknet-53</p>
<p>13 * 13， 26 * 26， 52*52， 3个detection</p>
<p>YOLOv3 为每个边界框都预测了一个分数 objectness score，打分依据是预测框与物体的重叠度。如果某个框的重叠度比其他框都高，它的分数就是 1</p>
]]></content>
      <categories>
        <category>草稿</category>
      </categories>
      <tags>
        <tag>Yolo发展整理</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客配合Github Action完成自动CI/CD</title>
    <url>/2021/05/04/hexo%E5%8D%9A%E5%AE%A2%E9%85%8D%E5%90%88Github-Action%E5%AE%8C%E6%88%90%E8%87%AA%E5%8A%A8CI-CD/</url>
    <content><![CDATA[<p>每次部署博客时都需要在本地完成编译和上传，维护工具链成为一件很繁琐的事情，有什么办法能够将这一步自动化，为将来随时随地写博客打下基础呢？</p>
<p>现在来一起学(白)习(嫖)Github Action吧！</p>
<p><small>PS.阅读本文，你需要提前了解一些sh和yaml相关的知识。</small></p>
<span id="more"></span>

<h2 id="CI实现"><a href="#CI实现" class="headerlink" title="CI实现"></a>CI实现</h2><p>为了从源码构建Hexo博客，我们需要进行如下几步：</p>
<ol>
<li>clone源码</li>
<li>clone主题(可选)</li>
<li>安装依赖</li>
<li>构建</li>
</ol>
<p>那么如果使用Github Action实现如上几步呢？</p>
<p>下面直接上配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Action 名称</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">Auto</span> <span class="string">Deploy</span></span><br><span class="line"><span class="comment"># 触发条件</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="comment"># 代码变动时触发</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span> [ <span class="string">master</span> ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 保留此行代表运行手动触发</span></span><br><span class="line">  <span class="comment"># 详情轻参考 https://docs.github.com/en/actions/reference/events-that-trigger-workflows#workflow_dispatch</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="comment"># 主题代码</span></span><br><span class="line">  <span class="attr">THEME_REPO:</span> <span class="string">theme-next/hexo-theme-next</span></span><br><span class="line">  <span class="attr">THEME_BRANCH:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="comment"># 工作环境</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># 设置时区</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">TimeZone</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">sudo</span> <span class="string">timedatectl</span> <span class="string">set-timezone</span> <span class="string">&quot;Asia/Shanghai&quot;</span></span><br><span class="line">      <span class="comment"># clone代码到~/Blog目录</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">Blog</span></span><br><span class="line">      <span class="comment"># 配置Node</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v2.1.5</span></span><br><span class="line">      <span class="comment"># 删除旧主题(可选)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Clear</span> <span class="string">old</span> <span class="string">theme</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">rm</span> <span class="string">-rf</span> <span class="string">themes/next</span></span><br><span class="line">      <span class="comment"># 拉取新主题(可选)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.THEME_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">Blog/themes/next</span></span><br><span class="line">      <span class="comment"># 安装主题配置文件，安装依赖</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">deps</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">cp</span> <span class="string">theme_config.yml</span> <span class="string">themes/next/_config.yml</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="comment"># 构建, 产物在~/Blog/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br></pre></td></tr></table></figure>

<h2 id="CD实现"><a href="#CD实现" class="headerlink" title="CD实现"></a>CD实现</h2><p>部署方式因人而异，我选择了最方便的Github Pages方式部署。以这种方式部署时，构建好的项目需要被上传到pages项目中。</p>
<p>创建pages项目的教程请参考 <a href="https://pages.github.com/%E3%80%82">https://pages.github.com/。</a></p>
<p>创建完成后，我们需要在pages项目的Settings-&gt;Deploy keys中增加一个公钥。</p>
<p>在博客源码项目中的Settings-&gt;Secrets-&gt;Actions secrets中增加一个私钥。此处我命名为了MAPLE_BLOG，并在步骤Set up git中使用。</p>
<p>密钥对的生成可以使用ssh-keygen(linux/mac)或puttygen(win)，此处不再赘述。</p>
<p>之后在上述流程中增加如下几个env和steps。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ... 省略了一些东西</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="comment"># 增加如下几个env</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">Casxt</span></span><br><span class="line">  <span class="attr">GIT_EMAIL:</span> <span class="number">774714620</span><span class="string">@qq.com</span></span><br><span class="line">  <span class="attr">DEPLOY_REPO:</span> <span class="string">casxt/casxt.github.io</span></span><br><span class="line">  <span class="attr">DEPLOY_BRANCH:</span> <span class="string">main</span></span><br><span class="line">  <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">git@github.com:casxt/blog.github.io.git</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="comment"># ... 构建的steps</span></span><br><span class="line">      <span class="comment"># 增加如下step</span></span><br><span class="line">      <span class="comment"># clone pages 项目到~/public目录</span></span><br><span class="line">      <span class="comment"># 需要注意的是我们构建好的产物在~/Blog/public</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">blog</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">$&#123;&#123;env.DEPLOY_REPO&#125;&#125;</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">$&#123;&#123;env.DEPLOY_BRANCH&#125;&#125;</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">public</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 设置私钥，以便向pages项目推送代码</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_KEY:</span> <span class="string">$&#123;&#123;secrets.MAPLE_BLOG&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;$DEPLOY_KEY&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">$GIT_USER</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">$GIT_EMAIL</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 拷贝产物，并push</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">git</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_GIT_REMOTE:</span> <span class="string">$&#123;&#123;env.DEPLOY_GIT_REMOTE&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">cd</span> <span class="string">Blog</span></span><br><span class="line">          <span class="string">cp</span> <span class="string">-R</span> <span class="string">public/*</span> <span class="string">../public/</span> </span><br><span class="line">          <span class="string">cd</span> <span class="string">../public/</span></span><br><span class="line">          <span class="string">git</span> <span class="string">remote</span> <span class="string">set-url</span> <span class="string">origin</span> <span class="string">$DEPLOY_GIT_REMOTE</span></span><br><span class="line">          <span class="string">git</span> <span class="string">add</span> <span class="string">.</span></span><br><span class="line">          <span class="string">git</span> <span class="string">commit</span> <span class="string">-m</span> <span class="string">&quot;auto deploy&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">push</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端技术</category>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>CI/CD</tag>
        <tag>Github Action</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables基础概念</title>
    <url>/2020/03/02/iptables%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>iptables 是标准的linux防火墙命令行控制工具, 其底层调用netfilter来实现各种功能</p>
<p>iptables 中最重要的概念就是 table, chain 和 rule</p>
<span id="more"></span>
<h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>iptables 中包含多个 table, 每个 table 又包含多个 chain, table 是 chain 的集合, 通常可以将 table 视作 chain 按照目的进行的分类</p>
<p>从数据进入网卡到流出网卡的过程中, iptables 会按照一定顺序调用各个 table 的 chain, 我们可以在某个 table 中添加 chain 或 rule 来在某个特定的时间点处理数据。</p>
<p>iptables 中包含了 raw, filter, nat, mangle, security 五个 table, 其中最常用的就是 nat 和 filter。</p>
<p>nat 中包含了会在数据<strong>收发阶段</strong>被调用的 chain, 因此可以用来对数据进行预处理和后处理。</p>
<p>filter 中包含了会在<strong>收发阶段</strong>和<strong>转发阶段</strong>被调用的 chain, 因此通常用来实现防火墙, 对数据的原目的地址端口协议等进行检查。</p>
<h1 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h1><p>chain 是规则(rule)的集合, 每个 table 中会包含数量不定的 chain, 不同 table 中的 chain 可能具有相同的名字 </p>
<p>例如 nat 中包含了 PREROUTING, POSTROUTING, OUTPUT 三个 chain, filter 中包含了 INPUT, OUTPUT, FORWARD 三个 chain</p>
<p>在 iptables 默认的5个 table 中, 每个 table 都包含了数量不一的 chain, 这些 chain 会在数据处理的各个节点被调用, 我们通过在这些默认的 chain 中添加 rule 就可以实现对数据包的捕获和处理。</p>
<h1 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h1><p>rule 是处理数据的具体规则, 数据收发过程中, iptables 会按照一定顺序调用各个 table 的 chain, 我们在这些 chain 中添加规则就可以随心所欲的处理数据。</p>
<p>通常来说, 一个 rule 功能包括:</p>
<ol>
<li>接受或拒绝一个包</li>
<li>将一个包送到某个 chain 里继续处理</li>
<li>改写包</li>
</ol>
<h1 id="调用顺序"><a href="#调用顺序" class="headerlink" title="调用顺序"></a>调用顺序</h1><p>按照下图所示, 我们只关注 filter 和 nat</p>
<p>对于收到的目的地址为本机的数据包, 依次经过 filter 和 nat 的5个 chain:</p>
<ol>
<li>nat: PEROUTING</li>
<li>filter: INPUT</li>
<li>nat: OUTPUT</li>
<li>filter: OUTPUT</li>
<li>nat: POSTOUTING</li>
</ol>
<p>对于收到的目的地址不为本机的数据包, 依次经过 filter 和 nat 的3个 chain:</p>
<ol>
<li>nat: PEROUTING</li>
<li>filter: FORWARD</li>
<li>nat: POSTOUTING</li>
</ol>
<blockquote>
<div style="width:50%;margin:auto"> <img src="/2020/03/02/iptables%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/iptables.jpg" class="" title="iptables 200"> </div>
<small>https://www.it.uu.se/edu/course/homepage/sakdat/vt09/pm/programme/iptables.pdfhexo</small>
</blockquote>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>table</tag>
        <tag>iptables</tag>
        <tag>chain</tag>
        <tag>rule</tag>
        <tag>filter</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib 多图组合显示</title>
    <url>/2020/05/28/matplotlib%E5%A4%9A%E5%9B%BE%E7%BB%84%E5%90%88%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, dpi=<span class="number">150</span>)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">0</span>].imshow(im1)</span><br><span class="line">axes[<span class="number">0</span>, <span class="number">1</span>].imshow(im2)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">0</span>].imshow(im3)</span><br><span class="line">axes[<span class="number">1</span>, <span class="number">1</span>].imshow(im4)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>只有一行时使用一维坐标</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, dpi=<span class="number">150</span>)</span><br><span class="line">axes[<span class="number">0</span>].imshow(im1)</span><br><span class="line">axes[<span class="number">1</span>].imshow(im2)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>matplotlib</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch GCN 实现以及使用</title>
    <url>/2020/03/05/pytorch-GCN-%E5%AE%9E%E7%8E%B0%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>从最为广泛和简单的理解来看, 在图上利用多个个节点数据进行计算的操作都可以称之为图网络</p>
<span id="more"></span>

<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>一张图由数个节点组成, 各个节点之间存在单向或双向的边。图只在概念上存在，实际上一张图由节点和邻接矩阵共同表示。</p>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>图中的一个概念上的点, 每个点都携带着一定量的数据。例如以下数据结构, 其中每一行代表一个点, 每一行中的数字代表该点所携带的数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4点, 每点包含一个5维的数据</span></span><br><span class="line">[<span class="number">0.4252</span>, <span class="number">0.2733</span>, <span class="number">0.5442</span>, <span class="number">0.7236</span>, <span class="number">0.0515</span>]</span><br><span class="line">[<span class="number">0.5121</span>, <span class="number">0.2056</span>, <span class="number">0.8560</span>, <span class="number">0.3010</span>, <span class="number">0.3110</span>]</span><br><span class="line">[<span class="number">0.0684</span>, <span class="number">0.5282</span>, <span class="number">0.8454</span>, <span class="number">0.0913</span>, <span class="number">0.9803</span>]</span><br><span class="line">[<span class="number">0.4211</span>, <span class="number">0.5779</span>, <span class="number">0.2952</span>, <span class="number">0.3368</span>, <span class="number">0.8389</span>]</span><br></pre></td></tr></table></figure>

<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p>邻接矩阵是一个 n * n 的矩阵, n 表示节点数目, 每一行都表示一个节点和其他节点是否相连。 对于一个无向图, 他的邻接矩阵总是对称的。例如以下数据结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4点邻接矩阵</span></span><br><span class="line">[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>]</span><br></pre></td></tr></table></figure>

<p>我们观察第一行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]</span><br></pre></td></tr></table></figure>

<p>表示节点0, 和节点0/2相连。</p>
<h1 id="GCN-定义"><a href="#GCN-定义" class="headerlink" title="GCN 定义"></a>GCN 定义</h1><h1 id="如何实现一个GCN模块"><a href="#如何实现一个GCN模块" class="headerlink" title="如何实现一个GCN模块"></a>如何实现一个GCN模块</h1><p>注意网络输入尺寸为<code>b*(n+c)*n</code>, 前<code>n</code>个channel构成的<code>b*n*n</code>表示邻接矩阵。后<code>b*c*n</code>表示节点数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">from torch import nn</span><br><span class="line">class GraphConvolution(nn.Module):</span><br><span class="line"></span><br><span class="line">    def __init__(self, node_num, input_feature_num, output_feature_num, add_bias&#x3D;True, dtype&#x3D;torch.float,</span><br><span class="line">                 batch_normal&#x3D;True):</span><br><span class="line">        super().__init__()</span><br><span class="line">        # shapes</span><br><span class="line">        self.graph_num &#x3D; node_num</span><br><span class="line">        self.input_feature_num &#x3D; input_feature_num</span><br><span class="line">        self.output_feature_num &#x3D; output_feature_num</span><br><span class="line">        self.add_bias &#x3D; add_bias</span><br><span class="line">        self.batch_normal &#x3D; batch_normal</span><br><span class="line"></span><br><span class="line">        # params</span><br><span class="line">        self.weight &#x3D; nn.Parameter(torch.empty(self.output_feature_num, input_feature_num, dtype&#x3D;dtype))</span><br><span class="line">        self.bias &#x3D; nn.Parameter(torch.empty(self.output_feature_num, self.graph_num, dtype&#x3D;dtype))</span><br><span class="line">        if batch_normal:</span><br><span class="line">            self.norm &#x3D; nn.InstanceNorm1d(node_num)</span><br><span class="line">            </span><br><span class="line">    def set_trainable(self, train&#x3D;True):</span><br><span class="line">        for param in self.parameters():</span><br><span class="line">            param.requires_grad &#x3D; train</span><br><span class="line"></span><br><span class="line">    def forward(self, inp: torch.Tensor):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        @param inp : adjacent: (batch, graph_num, graph_num) cat node_feature: (batch, graph_num, in_feature_num) -&gt; (batch, graph_num, graph_num + in_feature_num)</span><br><span class="line">        @return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        b, c, n &#x3D; inp.shape</span><br><span class="line">        adjacent, node_feature &#x3D; inp[:, 0:n, :], inp[:, n:, :]</span><br><span class="line">        x &#x3D; torch.matmul(self.weight, node_feature)</span><br><span class="line">        x &#x3D; torch.matmul(x, adjacent)</span><br><span class="line">        if self.add_bias:</span><br><span class="line">            x &#x3D; x + self.bias</span><br><span class="line">        if self.batch_normal:</span><br><span class="line">            x &#x3D; self.norm(x)</span><br><span class="line"></span><br><span class="line">        return torch.cat((adjacent, x), dim&#x3D;1)</span><br></pre></td></tr></table></figure>

<h1 id="残差GCN"><a href="#残差GCN" class="headerlink" title="残差GCN"></a>残差GCN</h1><h1 id="GCN存在的问题"><a href="#GCN存在的问题" class="headerlink" title="GCN存在的问题"></a>GCN存在的问题</h1><h1 id="训练中需要注意的"><a href="#训练中需要注意的" class="headerlink" title="训练中需要注意的"></a>训练中需要注意的</h1><ol>
<li>在训练GCN时必须谨慎使用Norm方法, 否则很可能造成网络不收敛</li>
<li>GCN梯度退化较为严重, 尽量使用残差结构</li>
</ol>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
        <tag>gcn</tag>
        <tag>rsenet</tag>
        <tag>残差</tag>
      </tags>
  </entry>
  <entry>
    <title>pytorch 矩阵操作</title>
    <url>/2020/03/05/pytorch-%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<span id="more"></span>

<h1 id="矩阵分片取坐标时超出矩阵范围"><a href="#矩阵分片取坐标时超出矩阵范围" class="headerlink" title="矩阵分片取坐标时超出矩阵范围"></a>矩阵分片取坐标时超出矩阵范围</h1><h2 id="分片出现小于0的坐标会导致赋值无效"><a href="#分片出现小于0的坐标会导致赋值无效" class="headerlink" title="分片出现小于0的坐标会导致赋值无效"></a>分片出现小于0的坐标会导致赋值无效</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y, x &#x3D; 1, 1</span><br><span class="line">nearby_mask &#x3D; torch.zeros((6, 6))</span><br><span class="line">nearby_mask[y - 2:y + 2, x - 2:x + 2] &#x3D; 1</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[[0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.]]</span><br></pre></td></tr></table></figure>

<h2 id="分片出现大于矩阵尺度的坐标会导致部分赋值"><a href="#分片出现大于矩阵尺度的坐标会导致部分赋值" class="headerlink" title="分片出现大于矩阵尺度的坐标会导致部分赋值"></a>分片出现大于矩阵尺度的坐标会导致部分赋值</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y, x &#x3D; 5, 2</span><br><span class="line">nearby_mask &#x3D; torch.zeros((6, 6))</span><br><span class="line">nearby_mask[y - 2:y + 2, x - 2:x + 2] &#x3D; 1</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[[0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [0., 0., 0., 0., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.],</span><br><span class="line"> [1., 1., 1., 1., 0., 0.]]</span><br></pre></td></tr></table></figure>

<h2 id="建议写法"><a href="#建议写法" class="headerlink" title="建议写法"></a>建议写法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nearby_mask[max(0, y - 2):y + 2, max(0, x - 2):x + 2] &#x3D; 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Wireguard 配置部署及技术讲解</title>
    <url>/2020/03/02/wireguard%E9%83%A8%E7%BD%B2%E5%8F%8A%E6%8A%80%E6%9C%AF%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.wireguard.com/">wiregurad</a>目前已经正式合入linux kernal, 日后的应用范围也一定会越来越广, 本文将会介绍如何使用wireguard创建自己的虚拟局域网, 并完成网关设置</p>
<span id="more"></span>

<h1 id="Wireguard-安装"><a href="#Wireguard-安装" class="headerlink" title="Wireguard 安装"></a>Wireguard 安装</h1><p>对于Ubuntu ≥ 19.10以上的用户, 直接安装即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt install wireguard</span></span><br></pre></td></tr></table></figure>
<p>对于19.04及以下用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo add-apt-repository ppa:wireguard/wireguard</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install wireguard</span></span><br></pre></td></tr></table></figure>

<h1 id="Wireguard-组网设置"><a href="#Wireguard-组网设置" class="headerlink" title="Wireguard 组网设置"></a>Wireguard 组网设置</h1><p>早期的教程中经常使用名为 <code>wg-quick</code> 的命令, 我个人非常不建议使用该工具, 而且官网也移除了关于此命令的相关描述, 因此接下来的操作都讲直接使用 <code>wg</code> 和 <code>ip</code> 命令完成。</p>
<p>wireguard必须在要组网的<strong>所有设备</strong>上都进行以下操作</p>
<h1 id="添加网卡"><a href="#添加网卡" class="headerlink" title="添加网卡"></a>添加网卡</h1><p>首先我们需要添加一块网卡, 并将其命名为 <code>wg0</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link add dev wg0 <span class="built_in">type</span> wireguard</span></span><br></pre></td></tr></table></figure>

<h1 id="设置ip"><a href="#设置ip" class="headerlink" title="设置ip"></a>设置ip</h1><p>添加网卡后为这张网卡配置ip, wireguard无法使用dhcp等功能，我们必须手动为其配置ip, 并且每个设备的ip都不能重复。</p>
<p>注意此处的子网掩码。这里指定的掩码将会在之后被用于设置ip route, 通常wg会自动设置, 但我们也可以手动设置, 这在之后会进行讲解。</p>
<p>因为我需要让所有设备都连接到一台公网设备, 所以我给我的公网设备分配了<code>192.168.100.1</code>的ip。其他设备依次使用<code>192.168.100.(2/3/4)</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip address add dev wg0 192.168.100.1/24</span></span><br></pre></td></tr></table></figure>

<h1 id="生成连接密钥"><a href="#生成连接密钥" class="headerlink" title="生成连接密钥"></a>生成连接密钥</h1><p>密钥是wg连中最为重要的一环。在两个节点之间, 数据的的接受和发送都需要单独的密钥对。</p>
<p>以A, B两设备为例。A需要持有A的私钥和B的公钥。B需要持有B的私钥和A的公钥。 B向A发送数据需要使用A的公钥。A接受B的数据需要使用A的私钥。</p>
<p>因此两个节点互联共需要2对共4个密钥。注意三个节点互联需要3对共6个密钥而不是4对共8个。因为节点的公钥可以给多个其他节点使用，不需要生成新的密钥对。</p>
<h2 id="生成一对密钥"><a href="#生成一对密钥" class="headerlink" title="生成一对密钥"></a>生成一对密钥</h2><h3 id="生成私钥"><a href="#生成私钥" class="headerlink" title="生成私钥"></a>生成私钥</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wg genkey</span></span><br><span class="line">6EQR4ABmq4otoOhSYVCJP4BBWKgLzIlTJ4QSPQZAR3s=</span><br></pre></td></tr></table></figure>
<h3 id="生成公钥"><a href="#生成公钥" class="headerlink" title="生成公钥"></a>生成公钥</h3><p>生成公钥需要使用之前的私钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> 6EQR4ABmq4otoOhSYVCJP4BBWKgLzIlTJ4QSPQZAR3s= | wg pubkey</span></span><br><span class="line">eCffMZ/2nN8nPDPap5lW4K4gDRw+UANqIQIvBebvTS4=</span><br></pre></td></tr></table></figure>

<h1 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h1><p>以下以一个公网设备A和一个私网(家宽)设备B为例</p>
<h2 id="有公网ip的设备-A"><a href="#有公网ip的设备-A" class="headerlink" title="有公网ip的设备 A"></a>有公网ip的设备 A</h2><p>对于有公网ip的设备, 我们不需要指定 peer 的地址(因为存在NAT指定了也没用), 我们只需要配置私钥和连接端口即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># file: A.conf</span><br><span class="line">[Interface]</span><br><span class="line"># Interface on A</span><br><span class="line">PrivateKey &#x3D; &lt;A的私钥&gt;</span><br><span class="line">ListenPort &#x3D; 10240</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line"># A to B</span><br><span class="line">PublicKey &#x3D; &lt;B的公钥&gt;</span><br><span class="line">AllowedIPs &#x3D; 192.168.100.2&#x2F;32</span><br><span class="line">PersistentKeepalive &#x3D; 10</span><br></pre></td></tr></table></figure>

<h2 id="无公网ip设备-B"><a href="#无公网ip设备-B" class="headerlink" title="无公网ip设备 B"></a>无公网ip设备 B</h2><p>对于有无公网ip的设备, 需要使用<code>Endpoint</code>指定 peer A 的地址, 这样才能在 A, B 之间建立起链接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># file: B.conf</span><br><span class="line">[Interface]</span><br><span class="line"># Interface on B</span><br><span class="line">PrivateKey &#x3D; &lt;B的私钥&gt;</span><br><span class="line">ListenPort &#x3D; 51820</span><br><span class="line"></span><br><span class="line">[Peer]</span><br><span class="line"># B to A</span><br><span class="line">PublicKey &#x3D; &lt;A的公钥&gt;</span><br><span class="line">Endpoint &#x3D; &lt;A的公网ip:10240&gt;</span><br><span class="line">AllowedIPs &#x3D; 192.168.100.0&#x2F;24</span><br><span class="line">PersistentKeepalive &#x3D; 10</span><br></pre></td></tr></table></figure>

<h2 id="AllowedIPs"><a href="#AllowedIPs" class="headerlink" title="AllowedIPs"></a>AllowedIPs</h2><p>需要注意两份配置的 AllowedIPs 不同, 对于A来说, peer B 的地址必须为<code>192.168.100.2/32</code>, 而对于B来说, 局域网中的所有 peer 都需要通过A来访问, 所以 AllowedIPs 被设置为 <code>192.168.100.0/24</code>。 </p>
<p>AllowedIPs类似于一个白名单机制, 只有目的地址在AllowedIPs中的包才允许发往该 peer。</p>
<h2 id="应用配置文件"><a href="#应用配置文件" class="headerlink" title="应用配置文件"></a>应用配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wg setconf wg0 xxxx.conf</span></span><br></pre></td></tr></table></figure>

<h1 id="启用网卡"><a href="#启用网卡" class="headerlink" title="启用网卡"></a>启用网卡</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip link <span class="built_in">set</span> up dev wg0</span></span><br></pre></td></tr></table></figure>

<h1 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h1><p>创建网卡之后, 我们还需要设置路由, 告诉系统使用wg0网卡处理发往192.168.100.0/24地址的数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip route add 192.168.100.0/24 dev wg0</span></span><br></pre></td></tr></table></figure>

<p>或者使用完整写法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip route add 192.168.100.0/24 dev wg0 proto kernel scope link src 192.168.100.x</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 192.168.100.x 指本机ip</span></span><br></pre></td></tr></table></figure>

<p>如果设置的时候提示 <code>RTNETLINK answers: File exists</code> 则表示wg已经自动设置过路由。可以使用以下命令查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo ip route</span> </span><br><span class="line">default via 192.168.1.1 dev enp6s0 proto dhcp src 192.168.1.4 metric 100</span><br><span class="line">192.168.100.0/24 dev wg0 proto kernel scope link src 192.168.100.2</span><br></pre></td></tr></table></figure>

<h1 id="查看连接状态"><a href="#查看连接状态" class="headerlink" title="查看连接状态"></a>查看连接状态</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo wg</span></span><br><span class="line">interface: wg0</span><br><span class="line">  public key: SaarEV3HLvcAaaLhorieaaalNMhCaaaxqVmIpmKwjWY=</span><br><span class="line">  private key: (hidden)</span><br><span class="line">  listening port: 10240</span><br><span class="line"></span><br><span class="line">peer: taaSMAMx4fMaaXfd1g4Z/c+AaapQRapYnStJ/wVFNjk=</span><br><span class="line">  endpoint: 111.20.8.222:51820</span><br><span class="line">  allowed ips: 192.168.100.2/32</span><br><span class="line">  latest handshake: 1 minute, 48 seconds ago</span><br><span class="line">  transfer: 256.64 KiB received, 200.38 KiB sent</span><br><span class="line">  persistent keepalive: every 10 seconds</span><br></pre></td></tr></table></figure>

<h1 id="网关设置"><a href="#网关设置" class="headerlink" title="网关设置"></a>网关设置</h1><p>请查看iptables forward 及 nat 相关讲解</p>
]]></content>
      <categories>
        <category>网络技术</category>
      </categories>
      <tags>
        <tag>route</tag>
        <tag>wireguard</tag>
        <tag>network</tag>
        <tag>ip</tag>
      </tags>
  </entry>
  <entry>
    <title>一个新奇的国产web引擎————YC编译器</title>
    <url>/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    <content><![CDATA[<p>最近在网上听说了一个国产的“浏览器”叫做YC浏览器，说是已经开发了好几年了，能把c++像js一样跑。</p>
<p>这种话一听就不靠谱嘛，微软这么大家业也不搞浏览器了。</p>
<p>抱着好奇心我打开了他们的官网：<a href="http://www.ycbro.com/">http://www.ycbro.com/</a>, 一看果然是编译器嘛不是什么浏览器 (然而编译器也没比浏览器简单多少…)。</p>
<p>反正软件也不大，抱着试试玩的心态，我也下了一个看看。</p>
<span id="more"></span>

<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>安装完成后看到两个快捷方式， “YC服务器 D__ycc” 和 “YC编译器 D__ycc”。</p>
<p>打开YC服务器可以看到一个非常复古的界面</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/1.jpg" class="" title="yc服务器界面 200"> </div>

<p>界面上的按钮我都点了一下，没啥用。</p>
<p>经过一番操作呢，我在他们安装目录下发现了一些模板的ysp文件，估计是文件名改了之后没有调整界面上的链接, 直接在浏览器输入路径, 这次成功的打开了<code>http://127.0.0.1/daoshi_info.ysp</code></p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/2.jpg" class="" title="导师信息界面 200"> </div>

<p>提示要安装access, 我比较偷懒就不安了。</p>
<h1 id="上传功能"><a href="#上传功能" class="headerlink" title="上传功能"></a>上传功能</h1><p>经过一番搜索我终于找到了一个功能还比较齐全的页面，也不需要数据库<code>http://127.0.0.1/upload.ysp</code>，有趣的是第一次访问还报错了404，过了一会再次访问就成功了，不禁让人想到这页面可能是动态编译的。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/3.jpg" class="" title="上传界面 200"> </div>

<p>随手上传了两个文件，页面功能还算正常，不过这些都是传统的js功能，并没有什么意思</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/4.jpg" class="" title="上传界面上传后 200"> </div>


<h1 id="代码编辑器"><a href="#代码编辑器" class="headerlink" title="代码编辑器"></a>代码编辑器</h1><p>yc还贴心的为我们提供了开发ide，虽然界面略显过时，但是也能看出开发者确实是在自己一点点打磨的，不然直接依托vscode搞一个ide会更香。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/6.jpg" class="" title="ide 200"> </div>

<p>这个ide甚至可以编辑二进制文件，难道这些开发者喜欢手写机器码吗</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/7.jpg" class="" title="二进制编辑 200"> </div>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p>打开yc源码目录，可以看到很多ysp文件和cpp文件，一入眼就是一堆avx，略显硬核</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/5.jpg" class="" title="源码 200"> </div>

<p>我打开了<code>sea.ysp</code>, 映入眼帘的是一堆c风格的代码，不过按照ysp的介绍应该是支持cpp的。</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/8.jpg" class="" title="sea.ysp 200"> </div>

<p>可以看出在ysp中prinft类似于php中的echo，用于在页面上输出元素。</p>
<p>顺便该页面的输出效果如下</p>
<div style="width:50%;margin:auto"> <img src="/2020/03/12/%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A5%87%E7%9A%84%E5%9B%BD%E4%BA%A7web%E5%BC%95%E6%93%8E%E2%80%94%E2%80%94%E2%80%94%E2%80%94YC%E7%BC%96%E8%AF%91%E5%99%A8/9.jpg" class="" title="sea.ysp页面 200"> </div>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>yc可以说是当代浮躁的代码界的一股清流，制作者不为外界所扰，潜心制作了一款cpp版php，虽然在当前的技术环境下很难说ycc能有多大的空间去施展拳脚，但至少从这个项目中可以看出老一辈程序员深厚的编程功底和耐得住寂寞的开发精神。</p>
]]></content>
      <categories>
        <category>大开眼界</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>yc</tag>
        <tag>浏览器</tag>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划相关题目</title>
    <url>/2021/05/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>动态规划类题目笔记</p>
<span id="more"></span>

<h1 id="买卖K次股票"><a href="#买卖K次股票" class="headerlink" title="买卖K次股票"></a>买卖K次股票</h1><p>假设当前天数为i，股价为p。</p>
<p>若此前一直不进行买卖，其最优利润为<code>dp[0] = 0</code>。</p>
<p>若此前只做过1次买入操作，且最优利润为<code>dp[1]</code>，考虑到今天的股价p。<br>则前i天只做过1次买入操作的最优利润为<code>max(dp[1], dp[0]-p)</code>。<code>dp[0]-p</code>表示如果以此前的最优无操作利润，在今天买入可获得的利润。</p>
<p>若此前只做过1次买入1次卖出操作，且最优利润为<code>dp[2]</code>，考虑到今天的股价p。<br>则前i天只做过1次买入1次卖出操作的最优利润为<code>max(dp[2], dp[1]+p)</code>。<code>dp[1]+p</code>表示如果以此前的最优1次买入的最优利润在今天卖出可获得的总利润。<code>dp[1]+p</code>更大则表示考虑到今天的价格，在今天卖出更合适。</p>
<p>若此前只做过2次买入1次卖出操作，且最优利润为<code>dp[3]</code>，考虑到今天的股价p。<br>则前i天只做过2次买入1次卖出操作的最优利润为<code>max(dp[3], dp[2]-p)</code>。<code>dp[2]-p</code>表示如果以此前的最优1次买入1次卖出可得利润的基础上，如果在今天买入可获得的利润。<code>dp[2]-p</code>更大则表示考虑到之前的买卖价格和今天的价格，在今天进行第2次买入要比在之前买入更合适。</p>
<p>若此前只做过2次买入2次卖出操作，且最优利润为<code>dp[4]</code>，考虑到今天的股价p。<br>则前i天只做过2次买入1次卖出操作的最优利润为<code>max(dp[4], dp[3]+p)</code>。<code>dp[3]+p</code>表示如果以此前的最优2次买入1次卖出的最优利润，在今天卖出可获得的总利润。<code>dp[3]+p</code>更大则表示考虑到今天的价格，在今天卖出更合适。</p>
<p>… …</p>
<h1 id="戳气球"><a href="#戳气球" class="headerlink" title="戳气球"></a>戳气球</h1><p><a href="https://leetcode-cn.com/problems/burst-balloons/">https://leetcode-cn.com/problems/burst-balloons/</a></p>
<p>使用逆向思维，从戳气球变为安置气球，对于区间[i,j]，遍历[i+1,j-1], 假设每一个位置k为第一插入气球，然后其值加上[i,k]和[k,j]的最优结果。</p>
<p>所有的k中，值最大的即为[i,j]中的最优结果。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>堆相关知识点</title>
    <url>/2021/05/03/%E5%A0%86%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>堆类题目堆相关知识点</p>
<span id="more"></span>

<h1 id="golang-最小堆实现"><a href="#golang-最小堆实现" class="headerlink" title="golang 最小堆实现"></a>golang 最小堆实现</h1><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/submissions/">https://leetcode-cn.com/problems/kth-largest-element-in-a-stream/submissions/</a></p>
<p>参考 <a href="https://ieevee.com/tech/2018/01/29/go-heap.html#2-containerheap%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95">https://ieevee.com/tech/2018/01/29/go-heap.html#2-containerheap%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95</a></p>
<p>container/heap</p>
<p>4.1 heap.Init</p>
<p>4.2 heap.Push</p>
<p>4.3 heap.Pop</p>
<p>4.4 heap.Fix</p>
<p>4.5 heap.Remove</p>
<p>实现</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> KthLargest <span class="keyword">struct</span> &#123;</span><br><span class="line">    sort.IntSlice</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IntSlice类型替我们实现了</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">func (h KthLargest) Len() int           &#123; return len(h) &#125;</span></span><br><span class="line"><span class="comment">func (h KthLargest) Less(i, j int) bool &#123; return h[i] &lt; h[j] &#125;</span></span><br><span class="line"><span class="comment">func (h KthLargest) Swap(i, j int)      &#123; h[i], h[j] = h[j], h[i] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// add x as element Len()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span> <span class="title">Push</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    kl.IntSlice = <span class="built_in">append</span>(kl.IntSlice, v.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// !!注意此处Pop的实现，由于golang heap库在调用heap.Pop方法时，先把元素和最后一个节点的值交换，然后弹出，然后调用 down。因此我们自己实现的方法接收到Pop时，需要被pop的元素实际已经被放置到队尾了</span></span><br><span class="line"><span class="comment">// remove and return element Len() - 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kl *KthLargest)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    a := kl.IntSlice</span><br><span class="line">    v := a[<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    kl.IntSlice = a[:<span class="built_in">len</span>(a)<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// heap.Push(kl, val)</span></span><br><span class="line"><span class="comment">// val = heap.Pop(kl)</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>知识点速查</tag>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>堆相关题目</title>
    <url>/2021/05/03/%E5%A0%86%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>堆类相关题目</p>
<span id="more"></span>

<h1 id="连续中值"><a href="#连续中值" class="headerlink" title="连续中值"></a>连续中值</h1><p>将半段数字放于一个小根堆，后半段放入大根堆</p>
<p>取小根堆和大根堆的堆顶即可推导出中位数</p>
<p>实际操作时，ruo</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>堆</tag>
      </tags>
  </entry>
  <entry>
    <title>子序列相关题目</title>
    <url>/2021/05/03/%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>子序列类相关题目</p>
<span id="more"></span>

<h1 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h1><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p>
<p>若nums的前n-1个元素的最大子序列和为M</p>
<p>nums的第N个元素为X</p>
<p>则nums的前n个元素的最大子序列和为max(M+X, X)</p>
<p>以此进行动态规划。</p>
<h1 id="简化路径"><a href="#简化路径" class="headerlink" title="简化路径"></a>简化路径</h1><p>模拟出入栈即可<br>字符串操作</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line">paths := strings.Split(path, <span class="string">&quot;/&quot;</span>)</span><br><span class="line">s := <span class="string">&quot;/&quot;</span> + strings.Join(stack, <span class="string">&quot;/&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>子序列</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相关题目</title>
    <url>/2021/05/03/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>字符串类相关题目</p>
<span id="more"></span>

<h1 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a>无重复字符的最长子串</h1><p><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>
<p>动态规划</p>
<p>已知以位置i-1结束的最长不重复串长为x, 若i处字符到其上一次出现的位置长为n</p>
<p>若 n &gt; x, 则 以位置i结束的最长不重复串长为x+1</p>
<p>若 n &lt;= x, 则 以位置i结束的最长不重复串长为n</p>
<h1 id="验证IP地址"><a href="#验证IP地址" class="headerlink" title="验证IP地址"></a>验证IP地址</h1><p><a href="https://leetcode-cn.com/problems/validate-ip-address/">https://leetcode-cn.com/problems/validate-ip-address/</a></p>
<p>10进制字符串转int<br>n, err := strconv.ParseInt(s, 10, 32)</p>
<p>16进制字符串转int<br>n, err := strconv.ParseInt(s, 16, 32)</p>
<h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><p><a href="https://leetcode-cn.com/problems/group-anagrams/">https://leetcode-cn.com/problems/group-anagrams/</a></p>
<p>字符串排序hash</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">code</span><span class="params">(str <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    s := []<span class="keyword">byte</span>(str)</span><br><span class="line">    sort.Slice(s, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> s[i] &lt; s[j] &#125;)</span><br><span class="line">    sortedStr := <span class="keyword">string</span>(s)</span><br><span class="line">    <span class="keyword">return</span> sortedStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">https://leetcode-cn.com/problems/minimum-window-substring/</a></p>
<p>双指针法，不匹配时右移右指针，匹配时记录最短串，并右移左指针。</p>
<p>直到右指针达到末尾并且不匹配</p>
<h1 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词" class="headerlink" title="找到字符串中所有字母异位词"></a>找到字符串中所有字母异位词</h1><p><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/">https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/</a></p>
<p>使用双指针标记窗口，移动窗口依次比较。</p>
<p>使用26长数组代替字典。</p>
<p>进阶：</p>
<p>每次移入元素使得字典某字母数量匹配目标数量，使match++</p>
<p>每次移出元素使得字典某字母数量从匹配目标数量变为不匹配，使match–</p>
<p>当match等于元素种类时，记录当前窗口起始位置</p>
<h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p>
<p><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/</a></p>
<p>递归遍历</p>
<p>每层选择一个位置i</p>
<p>如果i到达序列尾部，则记录结果，否则</p>
<p>依次将i 与 j([i, len])位置处的数据交换。</p>
<p>如果位置j处的数据在此层之前([i, j-1])出现过，则跳过到下一位置</p>
<p>交换数据后进行递归，从位置i+1开始</p>
<p>递归结束后再次交换，恢复序列，并循环下一j。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>手动挂载Nvidia显卡到docker容器中</title>
    <url>/2020/03/29/%E6%89%8B%E5%8A%A8%E6%8C%82%E8%BD%BDNvidia%E6%98%BE%E5%8D%A1%E5%88%B0docker%E5%AE%B9%E5%99%A8%E4%B8%AD/</url>
    <content><![CDATA[<p>在docker使用显卡往往需要nvidia的nvidia-container驱动，本文将叫你如何使用原生docker挂载显卡。<br>虽然在最新版的docker中已经内置了nvidia驱动，但是对于podman等其他容器管理来说，这套方法依旧是有意义的。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo docker run -it --rm \</span><br><span class="line">--device /dev/nvidia-uvm:/dev/nvidia-uvm:rwm \</span><br><span class="line">--device /dev/nvidia-uvm-tools:/dev/nvidia-uvm-tools:rwm \</span><br><span class="line">--device /dev/nvidia0:/dev/nvidia0:rwm \</span><br><span class="line">--device /dev/nvidiactl:/dev/nvidiactl:rwm \</span><br><span class="line">-v /usr/bin/nvidia-smi:/usr/bin/nvidia-smi:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu:/usr/lib/x86_64-linux-gnu:ro \</span><br><span class="line">ubuntu nvidia-smi</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h1 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h1><p>需要映射到容器中的控制设备包括</p>
<ul>
<li>/dev/nvidia-uvm</li>
<li>/dev/nvidia-uvm-tools</li>
<li>/dev/nvidiactl</li>
</ul>
<p>需要映射到容器中的显卡</p>
<ul>
<li>/dev/nvidia0</li>
<li>/dev/nvidia1</li>
</ul>
<p>可以根据需要自行增减数量，显卡编号从0开始，自动增加，nvidia0/nvidia1/nvidia2等等</p>
<h1 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h1><p>需要将nvidia驱动映射入容器</p>
<ul>
<li>/usr/bin/nvidia-smi</li>
<li>/usr/lib/x86_64-linux-gnu</li>
</ul>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>对于我们一开始的命令，其输出是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sun Mar 29 06:58:45 2020</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 440.33.01    Driver Version: 440.33.01    CUDA Version: 10.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage&#x2F;Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">|   0  GeForce RTX 208...  Off  | 00000000:AF:00.0 Off |                  N&#x2F;A |</span><br><span class="line">|  0%   25C    P8    15W &#x2F; 260W |      0MiB &#x2F; 11019MiB |      0%      Default |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                       GPU Memory |</span><br><span class="line">|  GPU       PID   Type   Process name                             Usage      |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">|  No running processes found                                                 |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>容器技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nvidia</tag>
        <tag>device</tag>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>数学相关题目</title>
    <url>/2021/05/03/%E6%95%B0%E5%AD%A6%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>数学类相关题目</p>
<span id="more"></span>

<h1 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h1><p><a href="https://leetcode-cn.com/problems/integer-break/">https://leetcode-cn.com/problems/integer-break/</a></p>
<p>考虑数字为4的情况，最大结果为2<em>2<br>考虑数字为5的情况，最大结果为2</em>3<br>考虑数字为6的情况，最大结果为3<em>3<br>考虑数字为7的情况，最大结果为3</em>2<em>2<br>考虑数字为8的情况，最大结果为3</em>3*2<br>所有大于3的数字一定可由2和3相加得到，归纳可证，需要将数字尽可能拆分为3相加</p>
<p>根据 n 除以 3 的余数进行分类讨论：</p>
<p>如果余数为 0，拆分为 n//3个3</p>
<p>如果余数为 1，拆分为 (n//3)-1 个 3和1个4</p>
<p>如果余数为 2，拆分为 n//3 个 3和1个2</p>
<h1 id="旋转数组"><a href="#旋转数组" class="headerlink" title="旋转数组"></a>旋转数组</h1><p><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p>
<p>较为复杂，多复习</p>
<p>不断将位置i和赋值给i+k,直到回到i</p>
<p>从i+1开始重复上述过程</p>
<p>直到处理过的数字和数组长度相等</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组相关题目</title>
    <url>/2021/05/03/%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>数组类相关题目</p>
<span id="more"></span>

<h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><p><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p>
<p>二分之后，必有一边是有序的(因为全局只有一个间断点，该点只能出现于一侧)。检查target是否坐落于有序一侧，如果不位于有序一侧，则一定位于无序一侧。</p>
<p>target取位于的那一侧继续迭代</p>
<h1 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h1><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">https://leetcode-cn.com/problems/first-missing-positive/</a></p>
<p>观察可知，题目所求正数不超过数组长度+1</p>
<p>遍历每一个位置，将该位置上的值x与位置x-1上的值y交换，重复交换直到x == y或 x &lt; 0 或 x &gt; 数组长度。</p>
<p>之后继续下一个位置</p>
<h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p>
<p>寻找左边界和有边界，二分条件大于小于情况照常处理，等于时，如果寻找左边界，则取左区间，反之右区间。</p>
<p>每次mid==target时记录最新的值</p>
<p>循环的s &gt; e 时跳出。</p>
<p>此时的最新mid值即为边界。</p>
<h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>
<p>贪心算法，构建队列，遍历数字，当数字大于队尾，则增加该数字，否则，找到第一个大于该数字的元素，修改为该数字。</p>
<p>通过二分查找加速</p>
<p>sort search会返回最小的满足true条件的位置，否则返回len(list)，注意函数中大于等于条件。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">idx := sort.Search(<span class="built_in">len</span>(list), <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;<span class="keyword">return</span> list[i] &gt;= n&#125;)</span><br><span class="line"><span class="keyword">if</span> idx &lt; <span class="built_in">len</span>(list) &#123;</span><br><span class="line">    list[idx] = n</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>树相关知识点</title>
    <url>/2021/05/03/%E6%A0%91%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>树类题目相关知识点</p>
<span id="more"></span>

<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><p>直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。<a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<h1 id="完全二叉树和满二叉树的区别"><a href="#完全二叉树和满二叉树的区别" class="headerlink" title="完全二叉树和满二叉树的区别"></a>完全二叉树和满二叉树的区别</h1><p>完全二叉树: 若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边。</p>
<p>满二叉树: 除最后一层无任何子 节点 外，每一层上的所有结点都有两个子结点</p>
<h1 id="前中后层序遍历"><a href="#前中后层序遍历" class="headerlink" title="前中后层序遍历"></a>前中后层序遍历</h1><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p>
<p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p>
<p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><p>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。</p>
<h1 id="求和路径"><a href="#求和路径" class="headerlink" title="求和路径"></a>求和路径</h1><p><a href="https://leetcode-cn.com/problems/paths-with-sum-lcci/">https://leetcode-cn.com/problems/paths-with-sum-lcci/</a></p>
<p><a href="https://leetcode-cn.com/problems/path-sum-iii/">https://leetcode-cn.com/problems/path-sum-iii/</a></p>
<p>通过记录前缀和并搜索的方式快速求解</p>
<h1 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h1><p><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">https://leetcode-cn.com/problems/implement-trie-prefix-tree/</a></p>
<p>每一个节点可以延伸出26路支路代表26个字母的树。</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>知识点速查</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>树相关题目</title>
    <url>/2021/05/03/%E6%A0%91%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>树类相关题目</p>
<span id="more"></span>

<h1 id="检查子树"><a href="#检查子树" class="headerlink" title="检查子树"></a>检查子树</h1><p><a href="https://leetcode-cn.com/problems/check-subtree-lcci/">https://leetcode-cn.com/problems/check-subtree-lcci/</a></p>
<p>递归比较，以每一个节点为头，比较2树是否相同即可</p>
<h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><p><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree/">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>
<p>经过某一结点的最长路径为 左子树高度+右子树高度</p>
<p>遍历每一个树中每一个节点，求得其左右子树高度并计算路径，取最大值作为树的直径</p>
<h1 id="完全二叉树的最后一层的最后一个节点"><a href="#完全二叉树的最后一层的最后一个节点" class="headerlink" title="完全二叉树的最后一层的最后一个节点"></a>完全二叉树的最后一层的最后一个节点</h1><p><a href="https://blog.csdn.net/fangjian1204/article/details/39179343">https://blog.csdn.net/fangjian1204/article/details/39179343</a></p>
<p>先计算树的高度，由于是完全二叉树，左节点遍历到底得到树高h。</p>
<p>之后进入算法</p>
<p>从根节点开始</p>
<p>若h==2，返回当前节点右，左中第一个非空的。</p>
<p>计算右子树高度，若高h，以右节点为根节点重新开始，否则以左节点为根节点重新开始。并令h-1</p>
<h1 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h1><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/submissions/</a></p>
<p>压栈法循环取出层</p>
<p>因为之字形打印，倒序遍历上一层，并根据需要按照从右到左或从左到右的顺序压节点</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>矩阵相关题目</title>
    <url>/2021/05/03/%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>矩阵类相关题目</p>
<span id="more"></span>

<h1 id="螺旋矩阵-回形打印二维数组"><a href="#螺旋矩阵-回形打印二维数组" class="headerlink" title="螺旋矩阵 回形打印二维数组"></a>螺旋矩阵 回形打印二维数组</h1><p><a href="https://leetcode-cn.com/problems/spiral-matrix/solution/">https://leetcode-cn.com/problems/spiral-matrix/solution/</a></p>
<p>使用四个循环依次打印四条边即可，使用计数器记录已经访问过的元素数目。</p>
<p>在打印上边和右边之后以及打印四条边之后判断计数器即可。</p>
<p>如果记不住，每条边打印前都判断一次也可</p>
<h1 id="旋转图像"><a href="#旋转图像" class="headerlink" title="旋转图像"></a>旋转图像</h1><p><a href="https://leetcode-cn.com/problems/rotate-image/">https://leetcode-cn.com/problems/rotate-image/</a></p>
<p>从左上角开始沿一条边逐个访问元素，</p>
<p>每个元素和其他四条边中相对起始位置相同的元素交换</p>
<p>他四条边中相对起始位置相同的元素坐标可以推算出来</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>链表相关题目</title>
    <url>/2021/05/03/%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%85%B3%E9%A2%98%E7%9B%AE/</url>
    <content><![CDATA[<p>链表类相关题目</p>
<span id="more"></span>

<h1 id="判断链表是否有环"><a href="#判断链表是否有环" class="headerlink" title="判断链表是否有环"></a>判断链表是否有环</h1><p><a href="https://leetcode-cn.com/problems/linked-list-cycle/submissions/">https://leetcode-cn.com/problems/linked-list-cycle/submissions/</a></p>
<p>快慢指针法, 快指针一次2步，慢指针一次1步，如果指针之一发现nil尾节点，则返回无环。<br>如果指针重合，返回有环。</p>
<h1 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h1><p><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p>
<p>使用双指针，分别从a, b开始遍历，到达a的末尾后衔接b的头。b也同理。</p>
<p>注意完成跳转的轮次不能进行其他工作，否则会导致头节点被错过。</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> pointA == <span class="literal">nil</span> &#123;</span><br><span class="line">    pointA = headB</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pointA = pointA.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
</search>
